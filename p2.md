## Top 20 Advanced Python Interview Questions (2 Years Experience)

### 1. **What is GIL (Global Interpreter Lock) and how does it affect multithreading?**
```python
import threading
import time

def cpu_bound_task():
    count = 0
    for i in range(100000000):
        count += 1
    return count

# GIL prevents true parallelism for CPU-bound tasks
start = time.time()
threads = []
for i in range(2):
    t = threading.Thread(target=cpu_bound_task)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
print(f"Time taken: {time.time() - start}")
```
**Concepts:** GIL, Threading limitations, CPU vs I/O bound tasks[1][2]

---

### 2. **Explain Python's Memory Management and Garbage Collection**
```python
import gc
import sys

# Reference counting
a = [1, 2, 3]
print(sys.getrefcount(a))  # Reference count

# Circular reference issue
class Node:
    def __init__(self, value):
        self.value = value
        self.ref = None

n1 = Node(1)
n2 = Node(2)
n1.ref = n2
n2.ref = n1  # Circular reference

# Manual garbage collection
gc.collect()
```
**Concepts:** Reference counting, Garbage collection, Memory leaks[2]

***

### 3. **Create a Custom Decorator with Arguments**
```python
def retry(max_attempts=3, delay=1):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    time.sleep(delay)
            return wrapper
    return decorator

@retry(max_attempts=3, delay=2)
def api_call():
    # Simulate API call that might fail
    import random
    if random.random() < 0.7:
        raise Exception("API failed")
    return "Success"
```
**Concepts:** Decorators with parameters, Nested functions, Exception handling[3][4]

***

### 4. **Implement a Generator for Fibonacci Sequence**
```python
def fibonacci_generator(n):
    a, b = 0, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

# Usage
fib_gen = fibonacci_generator(10)
for num in fib_gen:
    print(num, end=" ")

# Generator expression
squares = (x**2 for x in range(10))
```
**Concepts:** Generators, yield, Memory efficiency, Lazy evaluation[5][6]

***

### 5. **Context Manager Implementation**
```python
class DatabaseConnection:
    def __enter__(self):
        print("Opening database connection")
        self.connection = "DB Connection"
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing database connection")
        if exc_type:
            print(f"Exception occurred: {exc_val}")
        return False  # Don't suppress exceptions

# Usage
with DatabaseConnection() as db:
    print(f"Using {db}")
    # raise Exception("Something went wrong")

# Using contextlib
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    file = open(filename, mode)
    try:
        yield file
    finally:
        file.close()
```
**Concepts:** Context managers, __enter__/__exit__, contextlib[7]

***

### 6. **Metaclass Example**
```python
class SingletonMeta(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Singleton(metaclass=SingletonMeta):
    def __init__(self, value):
        self.value = value

# Usage
s1 = Singleton("first")
s2 = Singleton("second")
print(s1 is s2)  # True
print(s1.value)  # first (not changed)
```
**Concepts:** Metaclasses, Singleton pattern, Class creation[5]

***

### 7. **Async/Await and Asyncio**
```python
import asyncio
import aiohttp
import time

async def fetch_data(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = ['http://httpbin.org/delay/1'] * 5
    
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_data(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
    
    return results

# Compare sync vs async
start = time.time()
results = asyncio.run(main())
print(f"Async time: {time.time() - start}")
```
**Concepts:** Asynchronous programming, Event loop, Coroutines[1]

***

### 8. **Property Decorators and Descriptors**
```python
class Temperature:
    def __init__(self):
        self._celsius = 0
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("Temperature below absolute zero is not possible")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        return (self._celsius * 9/5) + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = (value - 32) * 5/9

# Descriptor example
class NonNegative:
    def __get__(self, obj, objtype=None):
        return obj.__dict__.get(self.name, 0)
    
    def __set__(self, obj, value):
        if value < 0:
            raise ValueError("Value must be non-negative")
        obj.__dict__[self.name] = value
    
    def __set_name__(self, owner, name):
        self.name = name

class Account:
    balance = NonNegative()
```
**Concepts:** Properties, Descriptors, Data validation[7]

---

### 9. **Advanced List Comprehensions and Generator Expressions**
```python
# Nested list comprehension
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row if num % 2 == 0]

# Dictionary comprehension with condition
text = "hello world"
char_count = {char: text.count(char) for char in set(text) if char != ' '}

# Set comprehension
unique_lengths = {len(word) for word in ["hello", "world", "python", "code"]}

# Generator expression for memory efficiency
large_squares = (x**2 for x in range(1000000) if x % 2 == 0)
```
**Concepts:** Comprehensions, Memory efficiency, Conditional expressions[5]

***

### 10. **Closures and Scope**
```python
def outer_function(x):
    def inner_function(y):
        return x + y  # x is captured from outer scope
    return inner_function

# Closure retains access to outer variables
add_10 = outer_function(10)
print(add_10(5))  # 15

# LEGB Rule example
x = "global"

def outer():
    x = "enclosing"
    
    def inner():
        x = "local"
        print(f"Inner: {x}")
    
    inner()
    print(f"Outer: {x}")

outer()
print(f"Global: {x}")
```
**Concepts:** Closures, Scope resolution, LEGB rule[7]

***

### 11. **Multiple Inheritance and MRO**
```python
class A:
    def method(self):
        print("A method")

class B(A):
    def method(self):
        print("B method")
        super().method()

class C(A):
    def method(self):
        print("C method")
        super().method()

class D(B, C):
    def method(self):
        print("D method")
        super().method()

d = D()
d.method()
print(D.__mro__)  # Method Resolution Order
```
**Concepts:** Multiple inheritance, MRO, Diamond problem[5]

***

### 12. **Custom Exception Classes**
```python
class ValidationError(Exception):
    def __init__(self, message, error_code=None):
        super().__init__(message)
        self.error_code = error_code
        self.timestamp = time.time()

class EmailValidationError(ValidationError):
    pass

def validate_email(email):
    if "@" not in email:
        raise EmailValidationError(
            "Invalid email format", 
            error_code="EMAIL_001"
        )

try:
    validate_email("invalid-email")
except EmailValidationError as e:
    print(f"Error: {e}")
    print(f"Code: {e.error_code}")
    print(f"Time: {e.timestamp}")
```
**Concepts:** Custom exceptions, Exception hierarchy, Error handling[7]

***

### 13. **Weak
```python
import weakref
import gc

class MyClass:
    def __init__(self, name):
        self.name = name
    
    def __del__(self):
        print(f"{self.name} is being deleted")

# Strong reference
obj = MyClass("Strong")
weak_ref = weakref.ref(obj)

print(weak_ref())  # Object exists
del obj
gc.collect()
print(weak_ref())  # None - object was deleted

# WeakValueDictionary
cache = weakref.WeakValueDictionary()
cache['key'] = MyClass("Cached")
```
**Concepts:** Weak references, Memory management, Garbage collection[1]

***

### 14. **Functional Programming Concepts**
```python
from functools import reduce, partial, wraps
from operator import add

# Higher-order functions
def apply_operation(operation, *args):
    return operation(*args)

result = apply_operation(lambda x, y: x * y, 5, 3)

# Partial functions
multiply_by_2 = partial(lambda x, y: x * y, 2)
print(multiply_by_2(5))  # 10

# Reduce with custom function
numbers = [1, 2, 3, 4, 5]
sum_all = reduce(add, numbers)
product = reduce(lambda x, y: x * y, numbers)

# Function composition
def compose(*functions):
    return reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x)

add_one = lambda x: x + 1
multiply_two = lambda x: x * 2
composed = compose(multiply_two, add_one)
print(composed(3))  # (3 + 1) * 2 = 8
```
**Concepts:** Functional programming, Higher-order functions, Composition[5]

***

### 15. **Advanced Data Structures**
```python
from collections import defaultdict, Counter, deque, namedtuple
from dataclasses import dataclass

# DefaultDict
dd = defaultdict(list)
dd['key'].append('value')  # No KeyError

# Counter
text = "hello world"
char_count = Counter(text)
print(char_count.most_common(3))

# Deque for efficient operations
dq = deque([1, 2, 3])
dq.appendleft(0)  # O(1) operation
dq.append(4)      # O(1) operation

# NamedTuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)

# DataClass (Python 3.7+)
@dataclass
class Person:
    name: str
    age: int
    
    def greet(self):
        return f"Hello, I'm {self.name}"
```
**Concepts:** Collections module, Data structures, Performance optimization[8]

***

### 16. **Slots for Memory Optimization**
```python
import sys

class RegularClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class SlottedClass:
    __slots__ = ['x', 'y']
    
    def __init__(self, x, y):
        self.x = x
        self.y = y

# Memory comparison
regular = RegularClass(1, 2)
slotted = SlottedClass(1, 2)

print(f"Regular: {sys.getsizeof(regular.__dict__)}")
print(f"Slotted: {sys.getsizeof(slotted)}")

# __slots__ prevents adding new attributes
# slotted.z = 3  # AttributeError
```
**Concepts:** __slots__, Memory optimization, Attribute access[1]

***

### 17. **Monkey Patching**
```python
class Calculator:
    def add(self, a, b):
        return a + b

# Monkey patching - adding method at runtime
def multiply(self, a, b):
    return a * b

Calculator.multiply = multiply

calc = Calculator()
print(calc.add(2, 3))      # 5
print(calc.multiply(2, 3)) # 6

# Patching built-in methods
original_len = len

def custom_len(obj):
    print(f"Getting length of {type(obj)}")
    return original_len(obj)

# Replace built-in len (not recommended in production)
__builtins__['len'] = custom_len
```
**Concepts:** Dynamic method addition, Runtime modification, Metaprogramming[7]

***

### 18. **Custom Iterator Protocol**
```python
class CountDown:
    def __init__(self, start):
        self.start = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1

# Usage
for num in CountDown(3):
    print(num)  # 3, 2, 1

# Range-like implementation
class MyRange:
    def __init__(self, start, end, step=1):
        self.start = start
        self.end = end
        self.step = step
    
    def __iter__(self):
        current = self.start
        while current < self.end:
            yield current
            current += self.step
```
**Concepts:** Iterator protocol, __iter__/__next__, Custom iteration[9]

***

### 19. **Multiprocessing vs Threading**
```python
import multiprocessing
import threading
import time

def cpu_intensive_task(n):
    count = 0
    for i in range(n):
        count += i ** 2
    return count

# Multiprocessing for CPU-bound tasks
def test_multiprocessing():
    start = time.time()
    with multiprocessing.Pool() as pool:
        results = pool.map(cpu_intensive_task, [1000000] * 4)
    print(f"Multiprocessing time: {time.time() - start}")

# Threading for I/O-bound tasks
def io_task():
    time.sleep(1)  # Simulate I/O
    return "done"

def test_threading():
    start = time.time()
    threads = []
    for _ in range(4):
        t = threading.Thread(target=io_task)
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()
    print(f"Threading time: {time.time() - start}")
```
**Concepts:** Multiprocessing, Threading, GIL implications, Concurrency[1]

***

### 20. **Advanced Exception Handling**
```python
class ResourceManager:
    def __init__(self, resource_name):
        self.resource_name = resource_name
    
    def __enter__(self):
        print(f"Acquiring {self.resource_name}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Releasing {self.resource_name}")
        
        if exc_type is ValueError:
            print("Handling ValueError gracefully")
            return True  # Suppress the exception
        
        return False  # Don't suppress other exceptions

# Multiple exception handling
def process_data(data):
    try:
        with ResourceManager("database"):
            if not data:
                raise ValueError("Empty data")
            if len(data) > 100:
                raise MemoryError("Data too large")
            return data.upper()
    
    except (ValueError, TypeError) as e:
        print(f"Data error: {e}")
        return None
    except MemoryError:
        print("Memory issue, processing in chunks")
        return data[:50].upper()
    else:
        print("Processing successful")
    finally:
        print("Cleanup completed")

# Exception chaining
def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError as e:
        raise ValueError("Invalid division operation") from e
```
**Concepts:** Exception handling, Context managers, Exception chaining[7]

***

**Tips for Interview:**
-  Yeh advanced concepts practice kar, real examples de interview me
- Memory management, concurrency, aur performance optimization pe focus kar
- Code likhte waqt edge cases handle kar
- Best practices aur design patterns ka knowledge dikhao

 **Yeh 20 advanced questions master kar le, confident rahega Python interview me!**
