Python OOP â€“ English Short Notes for Revision1. Class & ObjectClass: Blueprint/template for creating objects (like car design)Object: Instance of a class (actual car created from the design)class Car:
    pass
my_car = Car()  # Object created2. Constructor (init)Called automatically when object is createdUsed to initialize instance variablesdef __init__(self, name):
    self.name = name3. Instance vs Class VariablesInstance: Each object has its own copy (self.name)Class: Shared by all objects of the class (Car.wheels = 4)4. Method TypesInstance method: Takes self parameterClass method: Uses @classmethod, takes cls parameterStatic method: Uses @staticmethod, no self/cls needed5. EncapsulationData hiding using access modifiersPrivate variables: _variable (protected), __variable (private)self.__balance = 1000  # Private6. InheritanceChild class inherits properties from parent classclass Animal:  # Parent
class Dog(Animal):  # Child7. PolymorphismSame method name, different behavior in different classesAchieved through method overridingdef speak(self):  # Different implementation in each class8. AbstractionShow essential features, hide implementation detailsUse abstract classes: from abc import ABC, abstractmethod9. Method OverridingRedefining parent class method in child class10. super() FunctionUsed to access parent class methods and propertiesPython OOP Interview Q&A (2 Years Experience Level)1. Explain Class vs Object with exampleclass Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Objects
s1 = Student("Rahul", 20)
s2 = Student("Priya", 19)Concepts: Class definition, Constructor, Object creation2. Difference between Instance variable and Class variableclass Employee:
    company = "TCS"  # Class variable
    
    def __init__(self, name):
        self.name = name  # Instance variableConcepts: Variable scope, Memory management3. Implement Encapsulation - Bank Account exampleclass BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Private
    
    def get_balance(self):
        return self.__balance
    
    def deposit(self, amount):
        self.__balance += amountConcepts: Encapsulation, Private variables, Getter methods4. Inheritance example - Vehicle hierarchyclass Vehicle:
    def __init__(self, brand):
        self.brand = brand
    
    def start(self):
        print("Vehicle started")

class Car(Vehicle):
    def __init__(self, brand, model):
        super().__init__(brand)
        self.model = model
    
    def start(self):  # Method overriding
        print(f"{self.brand} car started")Concepts: Inheritance, super(), Method overriding5. How to implement Multiple Inheritance?class Father:
    def height(self):
        return "Tall"

class Mother:
    def eyes(self):
        return "Brown eyes"

class Child(Father, Mother):
    pass

c = Child()
print(c.height())  # Tall
print(c.eyes())    # Brown eyesConcepts: Multiple inheritance, Method Resolution Order (MRO)6. Polymorphism with method overridingclass Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

# Same method, different behavior
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.speak())Concepts: Polymorphism, Method overriding7. Create an Abstract classfrom abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius * self.radiusConcepts: Abstraction, Abstract methods8. Class method vs Static method vs Instance methodclass MyClass:
    class_var = "Class Variable"
    
    def instance_method(self):  # Instance method
        return self.class_var
    
    @classmethod
    def class_method(cls):  # Class method
        return cls.class_var
    
    @staticmethod
    def static_method():  # Static method
        return "Static method called"Concepts: Method types, Decorators9. Use Property decoratorclass Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def area(self):
        return 3.14 * self._radius * self._radius
    
    @area.setter
    def area(self, value):
        self._radius = (value / 3.14) ** 0.5

c = Circle(5)
print(c.area)  # Getter
c.area = 100   # SetterConcepts: Properties, Getter/Setter10. How to do Operator overloading?class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    
    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(3, 4)
p3 = p1 + p2  # __add__ method will be called
print(p3)  # (4, 6)Concepts: Operator overloading, Magic methods11. Difference between Composition vs Inheritance# Inheritance (is-a relationship)
class Car(Vehicle):
    pass

# Composition (has-a relationship)
class Car:
    def __init__(self):
        self.engine = Engine()  # Car HAS an engineConcepts: Design patterns, Code reusability12. What is Diamond problem in Python?class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")

class C(A):
    def method(self):
        print("C")

class D(B, C):
    pass

d = D()
d.method()  # Output: B (according to MRO)
print(D.__mro__)  # Method Resolution OrderConcepts: Multiple inheritance, MRO, Diamond problem13. Create Context manager (enter, exit)class FileManager:
    def __init__(self, filename):
        self.filename = filename
    
    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()

# Usage
with FileManager('test.txt') as f:
    f.write('Hello')Concepts: Context managers, Magic methods14. Implement Singleton patternclass Singleton:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # TrueConcepts: Design patterns, new method15. Basic Metaclass exampleclass MyMeta(type):
    def __new__(cls, name, bases, attrs):
        # Convert all method names to uppercase
        new_attrs = {}
        for key, value in attrs.items():
            if callable(value):
                new_attrs[key.upper()] = value
            else:
                new_attrs[key] = value
        return super().__new__(cls, name, bases, new_attrs)

class MyClass(metaclass=MyMeta):
    def hello(self):
        print("Hello")

obj = MyClass()
obj.HELLO()  # Method name became uppercaseConcepts: Metaclasses, Advanced OOPInterview Tips:Use real-world examples (Bank account, Car, Student)Explain concepts while writing codeConsider memory management and performance implicationsDemonstrate knowledge of design patterns (Singleton, Factory)Exception handling with OOP is also importantMaster these notes and questions for confident OOP interviews!